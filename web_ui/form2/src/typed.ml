open! Core
open! Bonsai_web
open! Bonsai.Let_syntax

module Record = struct
  module type S = sig
    module Typed_field : Typed_fields_lib.S

    type field_view
    type resulting_view

    val form_for_field : 'a Typed_field.t -> ('a, field_view) Form.t Computation.t

    type value_and_view_of_field_fn =
      { f : 'a. 'a Typed_field.t -> 'a Or_error.t * field_view }

    val finalize_view : value_and_view_of_field_fn -> resulting_view
  end

  let make
    (type a field_view resulting_view)
    (module M : S
      with type Typed_field.derived_on = a
       and type resulting_view = resulting_view
       and type field_view = field_view)
    =
    let module Form_value = struct
      type 'a t = ('a, field_view) Form.t Computation.t
    end
    in
    let module App = struct
      include Computation

      type 'a s = ('a, field_view) Form.t

      let translate = Fn.id
    end
    in
    let module Form' = struct
      type 'a t = ('a, field_view) Form.t
    end
    in
    let module The_form_values = Typed_field_map.Make (M.Typed_field) (Form_value) in
    let module The_forms = Typed_field_map.Make (M.Typed_field) (Form') in
    let module The_results = Typed_field_map.Make (M.Typed_field) (Or_error) in
    let module To_forms = The_form_values.As_applicative.To_other_map (App) (The_forms) in
    let form_values_per_field =
      let f field =
        let%sub subform = M.form_for_field field in
        let%arr subform = subform in
        Form.map_error
          subform
          ~f:(Error.tag ~tag:("in field " ^ M.Typed_field.name field))
      in
      The_form_values.create { f }
    in
    let%sub forms_per_field = To_forms.run form_values_per_field in
    let%arr forms_per_field = forms_per_field in
    let view =
      let lookup : type a. a M.Typed_field.t -> a Or_error.t * M.field_view =
        fun field ->
        let form = The_forms.find forms_per_field field in
        Form.value form, Form.view form
      in
      M.finalize_view { f = lookup }
    in
    let value =
      let f field = Form.value (The_forms.find forms_per_field field) in
      The_results.As_applicative.transpose
        (module Or_error)
        ~create:(fun { f } -> M.Typed_field.create { f })
        (The_results.create { f })
    in
    let set r =
      M.Typed_field.Packed.all
      |> List.map ~f:(fun { f = T field } ->
           Form.set (The_forms.find forms_per_field field) (M.Typed_field.get field r))
      |> Vdom.Effect.Many
    in
    { Form.view; value; set }
  ;;
end

module Variant = struct
  module type S = sig
    (**  This module should be generated by deriving [typed_variants] on a
         sum type. *)
    module Typed_variant : Typed_variants_lib.S

    type picker_view
    type variant_view
    type resulting_view

    val form_for_picker : (Typed_variant.Packed.t, picker_view) Form.t Computation.t
    val form_for_variant : 'a Typed_variant.t -> ('a, variant_view) Form.t Computation.t

    val finalize_view
      :  picker_view
      -> ('a Typed_variant.t * 'a Or_error.t * variant_view) Or_error.t
      -> resulting_view
  end

  let make
    (type a view picker_view variant_view)
    (module M : S
      with type Typed_variant.derived_on = a
       and type resulting_view = view
       and type variant_view = variant_view
       and type picker_view = picker_view)
    =
    let%sub { Form.value = picker_value; set = set_picker_value; view = picker_view } =
      M.form_for_picker
    in
    let module Packed_with_form = struct
      type t =
        | T :
            { variant : 'a M.Typed_variant.t
            ; form : ('a, M.variant_view) Form.t
            }
            -> t
    end
    in
    let%sub view, inner =
      match%sub picker_value with
      | Error e ->
        let%arr e = e
        and picker_view = picker_view in
        let view = M.finalize_view picker_view (Error e) in
        view, Error e
      | Ok picker_value ->
        let%sub inner =
          Bonsai.enum
            (module M.Typed_variant.Packed)
            ~match_:picker_value
            ~with_:(function
              | { f = T variant } ->
                let%map.Computation form = M.form_for_variant variant in
                Packed_with_form.T { variant; form })
        in
        let%arr (T { variant = picker_value; form = inner }) = inner
        and picker_view = picker_view in
        let view =
          M.finalize_view picker_view (Ok (picker_value, inner.value, inner.view))
        in
        let projected =
          let parse_exn content = M.Typed_variant.create picker_value content in
          let unparse kind =
            match M.Typed_variant.get picker_value kind with
            | None ->
              let expected = M.Typed_variant.Packed.pack picker_value in
              let found = M.Typed_variant.which kind in
              raise_s
                [%message
                  "BUG"
                    [%here]
                    (expected : M.Typed_variant.Packed.t)
                    (found : M.Typed_variant.Packed.t)]
            | Some v -> v
          in
          Form.project inner ~parse_exn ~unparse
        in
        view, Ok projected
    in
    let%sub get_inner_form = Bonsai.yoink inner in
    let%arr inner = inner
    and set_picker_value = set_picker_value
    and get_inner_form = get_inner_form
    and view = view in
    let set value =
      let constructor = M.Typed_variant.which value in
      let open Ui_effect.Let_syntax in
      (* sequence this so that the result of evaluating the picker is visible
         when setting the innermost form *)
      let%bind () = set_picker_value constructor in
      match%bind.Effect get_inner_form with
      | Active (Ok inner) -> Form.set inner value
      | Active (Error e) -> Effect.print_s [%sexp "BUG", [%here], (e : Error.t)]
      | Inactive -> Effect.never
    in
    let value =
      match inner with
      | Error e -> Error e
      | Ok form -> form.value
    in
    { Form.view; value; set }
  ;;
end
